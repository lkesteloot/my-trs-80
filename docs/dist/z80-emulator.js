(self["webpackChunkmy_trs_80"] = self["webpackChunkmy_trs_80"] || []).push([["z80-emulator"],{

/***/ "./node_modules/z80-emulator/dist/Decode.js":
/*!**************************************************!*\
  !*** ./node_modules/z80-emulator/dist/Decode.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Do not modify. This file was generated by GenerateOpcodes.ts.
Object.defineProperty(exports, "__esModule", ({ value: true }));
const z80_base_1 = __webpack_require__(/*! z80-base */ "./node_modules/z80-base/dist/index.js");
// Tables for computing flags after an operation.
const halfCarryAddTable = [0, z80_base_1.Flag.H, z80_base_1.Flag.H, z80_base_1.Flag.H, 0, 0, 0, z80_base_1.Flag.H];
const halfCarrySubTable = [0, 0, z80_base_1.Flag.H, 0, z80_base_1.Flag.H, 0, z80_base_1.Flag.H, z80_base_1.Flag.H];
const overflowAddTable = [0, 0, 0, z80_base_1.Flag.V, z80_base_1.Flag.V, 0, 0, 0];
const overflowSubTable = [0, z80_base_1.Flag.V, 0, 0, 0, 0, z80_base_1.Flag.V, 0];
const decodeMapBASE = new Map();
decodeMapBASE.set(0x00, (z80) => {
});
decodeMapBASE.set(0x01, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.bc = value;
});
decodeMapBASE.set(0x02, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.memptr = z80_base_1.word(z80.regs.a, z80_base_1.inc16(z80.regs.bc));
    z80.writeByte(z80.regs.bc, value);
});
decodeMapBASE.set(0x03, (z80) => {
    let value;
    value = z80.regs.bc;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.inc16(value);
    z80.regs.bc = value;
});
decodeMapBASE.set(0x04, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.b = value;
});
decodeMapBASE.set(0x05, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.b = value;
});
decodeMapBASE.set(0x06, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.b = value;
});
decodeMapBASE.set(0x07, (z80) => {
    const oldA = z80.regs.a;
    z80.regs.a = ((z80.regs.a >> 7) | (z80.regs.a << 1)) & 0xFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | ((oldA & 0x80) !== 0 ? z80_base_1.Flag.C : 0);
});
decodeMapBASE.set(0x08, (z80) => {
    const rightValue = z80.regs.afPrime;
    z80.regs.afPrime = z80.regs.af;
    z80.regs.af = rightValue;
});
decodeMapBASE.set(0x09, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x0A, (z80) => {
    let value;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    value = z80.readByte(z80.regs.bc);
    z80.regs.a = value;
});
decodeMapBASE.set(0x0B, (z80) => {
    let value;
    value = z80.regs.bc;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.dec16(value);
    z80.regs.bc = value;
});
decodeMapBASE.set(0x0C, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.c = value;
});
decodeMapBASE.set(0x0D, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.c = value;
});
decodeMapBASE.set(0x0E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.c = value;
});
decodeMapBASE.set(0x0F, (z80) => {
    const oldA = z80.regs.a;
    z80.regs.a = ((z80.regs.a >> 1) | (z80.regs.a << 7)) & 0xFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | ((oldA & 0x01) !== 0 ? z80_base_1.Flag.C : 0);
});
decodeMapBASE.set(0x10, (z80) => {
    z80.incTStateCount(1);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    if (z80.regs.b !== 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, z80_base_1.signedByte(offset));
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    }
    else {
        z80.incTStateCount(3);
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x11, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.de = value;
});
decodeMapBASE.set(0x12, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.memptr = z80_base_1.word(z80.regs.a, z80_base_1.inc16(z80.regs.de));
    z80.writeByte(z80.regs.de, value);
});
decodeMapBASE.set(0x13, (z80) => {
    let value;
    value = z80.regs.de;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.inc16(value);
    z80.regs.de = value;
});
decodeMapBASE.set(0x14, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.d = value;
});
decodeMapBASE.set(0x15, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.d = value;
});
decodeMapBASE.set(0x16, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.d = value;
});
decodeMapBASE.set(0x17, (z80) => {
    const oldA = z80.regs.a;
    z80.regs.a = ((z80.regs.a << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x01 : 0)) & 0xFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | ((oldA & 0x80) !== 0 ? z80_base_1.Flag.C : 0);
});
decodeMapBASE.set(0x18, (z80) => {
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.add16(z80.regs.pc, z80_base_1.signedByte(offset));
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0x19, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x1A, (z80) => {
    let value;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.de);
    value = z80.readByte(z80.regs.de);
    z80.regs.a = value;
});
decodeMapBASE.set(0x1B, (z80) => {
    let value;
    value = z80.regs.de;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.dec16(value);
    z80.regs.de = value;
});
decodeMapBASE.set(0x1C, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.e = value;
});
decodeMapBASE.set(0x1D, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.e = value;
});
decodeMapBASE.set(0x1E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.e = value;
});
decodeMapBASE.set(0x1F, (z80) => {
    const oldA = z80.regs.a;
    z80.regs.a = (z80.regs.a >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | ((oldA & 0x01) !== 0 ? z80_base_1.Flag.C : 0);
});
decodeMapBASE.set(0x20, (z80) => {
    if ((z80.regs.f & z80_base_1.Flag.Z) === 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, z80_base_1.signedByte(offset));
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    }
    else {
        z80.incTStateCount(3);
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x21, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x22, (z80) => {
    let value;
    value = z80.regs.hl;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapBASE.set(0x23, (z80) => {
    let value;
    value = z80.regs.hl;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.inc16(value);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x24, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.h = value;
});
decodeMapBASE.set(0x25, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.h = value;
});
decodeMapBASE.set(0x26, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.h = value;
});
decodeMapBASE.set(0x27, (z80) => {
    let value = 0;
    let carry = z80.regs.f & z80_base_1.Flag.C;
    if ((z80.regs.f & z80_base_1.Flag.H) !== 0 || ((z80.regs.a & 0x0F) > 9)) {
        value = 6; // Skip over hex digits in lower nybble.
    }
    if (carry !== 0 || z80.regs.a > 0x99) {
        value |= 0x60; // Skip over hex digits in upper nybble.
    }
    if (z80.regs.a > 0x99) {
        carry = z80_base_1.Flag.C;
    }
    if ((z80.regs.f & z80_base_1.Flag.N) !== 0) {
        let result = z80_base_1.sub16(z80.regs.a, value);
        const lookup = (((z80.regs.a & 0x88) >> 3) |
            ((value & 0x88) >> 2) |
            ((result & 0x88) >> 1)) & 0xFF;
        z80.regs.a = result & 0xFF;
        z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
    }
    else {
        let result = z80_base_1.add16(z80.regs.a, value);
        const lookup = (((z80.regs.a & 0x88) >> 3) |
            ((value & 0x88) >> 2) |
            ((result & 0x88) >> 1)) & 0xFF;
        z80.regs.a = result & 0xFF;
        z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
    }
    z80.regs.f = (z80.regs.f & ~(z80_base_1.Flag.C | z80_base_1.Flag.P)) | carry | z80.parityTable[z80.regs.a];
});
decodeMapBASE.set(0x28, (z80) => {
    if ((z80.regs.f & z80_base_1.Flag.Z) !== 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, z80_base_1.signedByte(offset));
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    }
    else {
        z80.incTStateCount(3);
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x29, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.hl;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x2A, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x2B, (z80) => {
    let value;
    value = z80.regs.hl;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.dec16(value);
    z80.regs.hl = value;
});
decodeMapBASE.set(0x2C, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.l = value;
});
decodeMapBASE.set(0x2D, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.l = value;
});
decodeMapBASE.set(0x2E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.l = value;
});
decodeMapBASE.set(0x2F, (z80) => {
    z80.regs.a ^= 0xFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.C | z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | z80_base_1.Flag.N | z80_base_1.Flag.H;
});
decodeMapBASE.set(0x30, (z80) => {
    if ((z80.regs.f & z80_base_1.Flag.C) === 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, z80_base_1.signedByte(offset));
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    }
    else {
        z80.incTStateCount(3);
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x31, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.sp = value;
});
decodeMapBASE.set(0x32, (z80) => {
    let value;
    value = z80.regs.a;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.regs.a, z80_base_1.inc16(value));
    z80.writeByte(value, z80.regs.a);
});
decodeMapBASE.set(0x33, (z80) => {
    let value;
    value = z80.regs.sp;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.inc16(value);
    z80.regs.sp = value;
});
decodeMapBASE.set(0x34, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x35, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x36, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x37, (z80) => {
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | z80_base_1.Flag.C | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
});
decodeMapBASE.set(0x38, (z80) => {
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        const offset = z80.readByte(z80.regs.pc);
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, z80_base_1.signedByte(offset));
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
        z80.regs.memptr = z80.regs.pc;
    }
    else {
        z80.incTStateCount(3);
        z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    }
});
decodeMapBASE.set(0x39, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.hl + value;
    const lookup = (((z80.regs.hl & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapBASE.set(0x3A, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.inc16(value);
    value = z80.readByte(value);
    z80.regs.a = value;
});
decodeMapBASE.set(0x3B, (z80) => {
    let value;
    value = z80.regs.sp;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.dec16(value);
    z80.regs.sp = value;
});
decodeMapBASE.set(0x3C, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.a = value;
});
decodeMapBASE.set(0x3D, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.a = value;
});
decodeMapBASE.set(0x3E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.a = value;
});
decodeMapBASE.set(0x3F, (z80) => {
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.P | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? z80_base_1.Flag.H : z80_base_1.Flag.C) | (z80.regs.a & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
});
decodeMapBASE.set(0x40, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.b = value;
});
decodeMapBASE.set(0x41, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.b = value;
});
decodeMapBASE.set(0x42, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.b = value;
});
decodeMapBASE.set(0x43, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.b = value;
});
decodeMapBASE.set(0x44, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.b = value;
});
decodeMapBASE.set(0x45, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.b = value;
});
decodeMapBASE.set(0x46, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.b = value;
});
decodeMapBASE.set(0x47, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.b = value;
});
decodeMapBASE.set(0x48, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.c = value;
});
decodeMapBASE.set(0x49, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4A, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4B, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4C, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4D, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.c = value;
});
decodeMapBASE.set(0x4E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.c = value;
});
decodeMapBASE.set(0x4F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.c = value;
});
decodeMapBASE.set(0x50, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.d = value;
});
decodeMapBASE.set(0x51, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.d = value;
});
decodeMapBASE.set(0x52, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.d = value;
});
decodeMapBASE.set(0x53, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.d = value;
});
decodeMapBASE.set(0x54, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.d = value;
});
decodeMapBASE.set(0x55, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.d = value;
});
decodeMapBASE.set(0x56, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.d = value;
});
decodeMapBASE.set(0x57, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.d = value;
});
decodeMapBASE.set(0x58, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.e = value;
});
decodeMapBASE.set(0x59, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5A, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5B, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5C, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5D, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.e = value;
});
decodeMapBASE.set(0x5E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.e = value;
});
decodeMapBASE.set(0x5F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.e = value;
});
decodeMapBASE.set(0x60, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.h = value;
});
decodeMapBASE.set(0x61, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.h = value;
});
decodeMapBASE.set(0x62, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.h = value;
});
decodeMapBASE.set(0x63, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.h = value;
});
decodeMapBASE.set(0x64, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.h = value;
});
decodeMapBASE.set(0x65, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.h = value;
});
decodeMapBASE.set(0x66, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.h = value;
});
decodeMapBASE.set(0x67, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.h = value;
});
decodeMapBASE.set(0x68, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.l = value;
});
decodeMapBASE.set(0x69, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6A, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6B, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6C, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6D, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.l = value;
});
decodeMapBASE.set(0x6E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.l = value;
});
decodeMapBASE.set(0x6F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.l = value;
});
decodeMapBASE.set(0x70, (z80) => {
    let value;
    value = z80.regs.b;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x71, (z80) => {
    let value;
    value = z80.regs.c;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x72, (z80) => {
    let value;
    value = z80.regs.d;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x73, (z80) => {
    let value;
    value = z80.regs.e;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x74, (z80) => {
    let value;
    value = z80.regs.h;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x75, (z80) => {
    let value;
    value = z80.regs.l;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x76, (z80) => {
    z80.regs.halted = 1;
    z80.regs.pc = z80_base_1.dec16(z80.regs.pc);
});
decodeMapBASE.set(0x77, (z80) => {
    let value;
    value = z80.regs.a;
    z80.writeByte(z80.regs.hl, value);
});
decodeMapBASE.set(0x78, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.a = value;
});
decodeMapBASE.set(0x79, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7A, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7B, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7C, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7D, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.a = value;
});
decodeMapBASE.set(0x7E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a = value;
});
decodeMapBASE.set(0x7F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.a = value;
});
decodeMapBASE.set(0x80, (z80) => {
    let value;
    value = z80.regs.b;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x81, (z80) => {
    let value;
    value = z80.regs.c;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x82, (z80) => {
    let value;
    value = z80.regs.d;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x83, (z80) => {
    let value;
    value = z80.regs.e;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x84, (z80) => {
    let value;
    value = z80.regs.h;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x85, (z80) => {
    let value;
    value = z80.regs.l;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x86, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x87, (z80) => {
    let value;
    value = z80.regs.a;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x88, (z80) => {
    let value;
    value = z80.regs.b;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x89, (z80) => {
    let value;
    value = z80.regs.c;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8A, (z80) => {
    let value;
    value = z80.regs.d;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8B, (z80) => {
    let value;
    value = z80.regs.e;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8C, (z80) => {
    let value;
    value = z80.regs.h;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8D, (z80) => {
    let value;
    value = z80.regs.l;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x8F, (z80) => {
    let value;
    value = z80.regs.a;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x90, (z80) => {
    let value;
    value = z80.regs.b;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x91, (z80) => {
    let value;
    value = z80.regs.c;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x92, (z80) => {
    let value;
    value = z80.regs.d;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x93, (z80) => {
    let value;
    value = z80.regs.e;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x94, (z80) => {
    let value;
    value = z80.regs.h;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x95, (z80) => {
    let value;
    value = z80.regs.l;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x96, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x97, (z80) => {
    let value;
    value = z80.regs.a;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x98, (z80) => {
    let value;
    value = z80.regs.b;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x99, (z80) => {
    let value;
    value = z80.regs.c;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9A, (z80) => {
    let value;
    value = z80.regs.d;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9B, (z80) => {
    let value;
    value = z80.regs.e;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9C, (z80) => {
    let value;
    value = z80.regs.h;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9D, (z80) => {
    let value;
    value = z80.regs.l;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0x9F, (z80) => {
    let value;
    value = z80.regs.a;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xA0, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA1, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA2, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA3, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA4, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA5, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA7, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xA8, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xA9, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAA, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAB, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAC, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAD, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xAF, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB0, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB1, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB2, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB3, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB4, (z80) => {
    let value;
    value = z80.regs.h;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB5, (z80) => {
    let value;
    value = z80.regs.l;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB7, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xB8, (z80) => {
    let value;
    value = z80.regs.b;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xB9, (z80) => {
    let value;
    value = z80.regs.c;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xBA, (z80) => {
    let value;
    value = z80.regs.d;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xBB, (z80) => {
    let value;
    value = z80.regs.e;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xBC, (z80) => {
    let value;
    value = z80.regs.h;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xBD, (z80) => {
    let value;
    value = z80.regs.l;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xBE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xBF, (z80) => {
    let value;
    value = z80.regs.a;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xC0, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.Z) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xC1, (z80) => {
    z80.regs.bc = z80.popWord();
});
decodeMapBASE.set(0xC2, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.Z) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xC3, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.pc = z80.regs.memptr;
});
decodeMapBASE.set(0xC4, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.Z) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xC5, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.bc);
});
decodeMapBASE.set(0xC6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xC7, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0000;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xC8, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.Z) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xC9, (z80) => {
    z80.regs.pc = z80.popWord();
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xCA, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.Z) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xCB, (z80) => {
    decodeCB(z80);
});
decodeMapBASE.set(0xCC, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.Z) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xCD, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = z80.regs.memptr;
});
decodeMapBASE.set(0xCE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xCF, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0008;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xD0, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.C) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xD1, (z80) => {
    z80.regs.de = z80.popWord();
});
decodeMapBASE.set(0xD2, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.C) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xD3, (z80) => {
    const port = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.regs.a, z80_base_1.inc8(port));
    z80.writePort(z80_base_1.word(z80.regs.a, port), z80.regs.a);
});
decodeMapBASE.set(0xD4, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.C) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xD5, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.de);
});
decodeMapBASE.set(0xD6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xD7, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0010;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xD8, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xD9, (z80) => {
    let tmp;
    tmp = z80.regs.bc;
    z80.regs.bc = z80.regs.bcPrime;
    z80.regs.bcPrime = tmp;
    tmp = z80.regs.de;
    z80.regs.de = z80.regs.dePrime;
    z80.regs.dePrime = tmp;
    tmp = z80.regs.hl;
    z80.regs.hl = z80.regs.hlPrime;
    z80.regs.hlPrime = tmp;
});
decodeMapBASE.set(0xDA, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xDB, (z80) => {
    const port = z80_base_1.word(z80.regs.a, z80.readByte(z80.regs.pc));
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.a = z80.readPort(port);
    z80.regs.memptr = z80_base_1.inc16(port);
});
decodeMapBASE.set(0xDC, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xDD, (z80) => {
    decodeDD(z80);
});
decodeMapBASE.set(0xDE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapBASE.set(0xDF, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0018;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xE0, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.P) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xE1, (z80) => {
    z80.regs.hl = z80.popWord();
});
decodeMapBASE.set(0xE2, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.P) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xE3, (z80) => {
    const rightValue = z80.regs.hl;
    const leftValueL = z80.readByte(z80.regs.sp);
    const leftValueH = z80.readByte(z80_base_1.inc16(z80.regs.sp));
    z80.incTStateCount(1);
    z80.writeByte(z80_base_1.inc16(z80.regs.sp), z80_base_1.hi(rightValue));
    z80.writeByte(z80.regs.sp, z80_base_1.lo(rightValue));
    z80.incTStateCount(2);
    z80.regs.memptr = z80_base_1.word(leftValueH, leftValueL);
    z80.regs.hl = z80_base_1.word(leftValueH, leftValueL);
});
decodeMapBASE.set(0xE4, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.P) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xE5, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.hl);
});
decodeMapBASE.set(0xE6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapBASE.set(0xE7, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0020;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xE8, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.P) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xE9, (z80) => {
    z80.regs.pc = z80.regs.hl;
});
decodeMapBASE.set(0xEA, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.P) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xEB, (z80) => {
    const rightValue = z80.regs.hl;
    z80.regs.hl = z80.regs.de;
    z80.regs.de = rightValue;
});
decodeMapBASE.set(0xEC, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.P) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xED, (z80) => {
    decodeED(z80);
});
decodeMapBASE.set(0xEE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xEF, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0028;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xF0, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.S) === 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xF1, (z80) => {
    z80.regs.af = z80.popWord();
});
decodeMapBASE.set(0xF2, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.S) === 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xF3, (z80) => {
    z80.regs.iff1 = 0;
    z80.regs.iff2 = 0;
});
decodeMapBASE.set(0xF4, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.S) === 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xF5, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.af);
});
decodeMapBASE.set(0xF6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapBASE.set(0xF7, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0030;
    z80.regs.memptr = z80.regs.pc;
});
decodeMapBASE.set(0xF8, (z80) => {
    z80.incTStateCount(1);
    if ((z80.regs.f & z80_base_1.Flag.S) !== 0) {
        z80.regs.pc = z80.popWord();
        z80.regs.memptr = z80.regs.pc;
    }
});
decodeMapBASE.set(0xF9, (z80) => {
    let value;
    value = z80.regs.hl;
    z80.incTStateCount(2);
    z80.regs.sp = value;
});
decodeMapBASE.set(0xFA, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.S) !== 0) {
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xFB, (z80) => {
    z80.regs.iff1 = 1;
    z80.regs.iff2 = 1;
});
decodeMapBASE.set(0xFC, (z80) => {
    z80.regs.memptr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.word(z80.readByte(z80.regs.pc), z80.regs.memptr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    if ((z80.regs.f & z80_base_1.Flag.S) !== 0) {
        z80.incTStateCount(1);
        z80.pushWord(z80.regs.pc);
        z80.regs.pc = z80.regs.memptr;
    }
});
decodeMapBASE.set(0xFD, (z80) => {
    decodeFD(z80);
});
decodeMapBASE.set(0xFE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapBASE.set(0xFF, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.pc);
    z80.regs.pc = 0x0038;
    z80.regs.memptr = z80.regs.pc;
});
const decodeMapCB = new Map();
decodeMapCB.set(0x00, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x01, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x02, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x03, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x04, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x05, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x06, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x07, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x08, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x09, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x0A, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x0B, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x0C, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x0D, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x0E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x0F, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x10, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x11, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x12, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x13, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x14, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x15, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x16, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x17, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x18, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x19, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x1A, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x1B, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x1C, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x1D, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x1E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x1F, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x20, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x21, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x22, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x23, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x24, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x25, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x26, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x27, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x28, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x29, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x2A, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x2B, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x2C, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x2D, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x2E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x2F, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x30, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x31, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x32, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x33, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x34, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x35, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x36, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x37, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x38, (z80) => {
    let value;
    value = z80.regs.b;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.b = value;
});
decodeMapCB.set(0x39, (z80) => {
    let value;
    value = z80.regs.c;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.c = value;
});
decodeMapCB.set(0x3A, (z80) => {
    let value;
    value = z80.regs.d;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.d = value;
});
decodeMapCB.set(0x3B, (z80) => {
    let value;
    value = z80.regs.e;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.e = value;
});
decodeMapCB.set(0x3C, (z80) => {
    let value;
    value = z80.regs.h;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.h = value;
});
decodeMapCB.set(0x3D, (z80) => {
    let value;
    value = z80.regs.l;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.l = value;
});
decodeMapCB.set(0x3E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.hl, value);
});
decodeMapCB.set(0x3F, (z80) => {
    let value;
    value = z80.regs.a;
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.regs.a = value;
});
decodeMapCB.set(0x40, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x41, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x42, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x43, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x44, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x45, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x46, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x47, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x48, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x49, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4A, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4B, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4C, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4D, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4E, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x4F, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x50, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x51, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x52, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x53, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x54, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x55, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x56, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x57, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x58, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x59, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5A, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5B, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5C, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5D, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5E, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x5F, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x60, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x61, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x62, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x63, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x64, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x65, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x66, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x67, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x68, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x69, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6A, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6B, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6C, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6D, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6E, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x6F, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x70, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x71, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x72, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x73, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x74, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x75, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x76, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x77, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x78, (z80) => {
    const value = z80.regs.b;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x79, (z80) => {
    const value = z80.regs.c;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7A, (z80) => {
    const value = z80.regs.d;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7B, (z80) => {
    const value = z80.regs.e;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7C, (z80) => {
    const value = z80.regs.h;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7D, (z80) => {
    const value = z80.regs.l;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7E, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x7F, (z80) => {
    const value = z80.regs.a;
    const hiddenValue = value;
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapCB.set(0x80, (z80) => {
    z80.regs.b &= 0xFE;
});
decodeMapCB.set(0x81, (z80) => {
    z80.regs.c &= 0xFE;
});
decodeMapCB.set(0x82, (z80) => {
    z80.regs.d &= 0xFE;
});
decodeMapCB.set(0x83, (z80) => {
    z80.regs.e &= 0xFE;
});
decodeMapCB.set(0x84, (z80) => {
    z80.regs.h &= 0xFE;
});
decodeMapCB.set(0x85, (z80) => {
    z80.regs.l &= 0xFE;
});
decodeMapCB.set(0x86, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xFE);
});
decodeMapCB.set(0x87, (z80) => {
    z80.regs.a &= 0xFE;
});
decodeMapCB.set(0x88, (z80) => {
    z80.regs.b &= 0xFD;
});
decodeMapCB.set(0x89, (z80) => {
    z80.regs.c &= 0xFD;
});
decodeMapCB.set(0x8A, (z80) => {
    z80.regs.d &= 0xFD;
});
decodeMapCB.set(0x8B, (z80) => {
    z80.regs.e &= 0xFD;
});
decodeMapCB.set(0x8C, (z80) => {
    z80.regs.h &= 0xFD;
});
decodeMapCB.set(0x8D, (z80) => {
    z80.regs.l &= 0xFD;
});
decodeMapCB.set(0x8E, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xFD);
});
decodeMapCB.set(0x8F, (z80) => {
    z80.regs.a &= 0xFD;
});
decodeMapCB.set(0x90, (z80) => {
    z80.regs.b &= 0xFB;
});
decodeMapCB.set(0x91, (z80) => {
    z80.regs.c &= 0xFB;
});
decodeMapCB.set(0x92, (z80) => {
    z80.regs.d &= 0xFB;
});
decodeMapCB.set(0x93, (z80) => {
    z80.regs.e &= 0xFB;
});
decodeMapCB.set(0x94, (z80) => {
    z80.regs.h &= 0xFB;
});
decodeMapCB.set(0x95, (z80) => {
    z80.regs.l &= 0xFB;
});
decodeMapCB.set(0x96, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xFB);
});
decodeMapCB.set(0x97, (z80) => {
    z80.regs.a &= 0xFB;
});
decodeMapCB.set(0x98, (z80) => {
    z80.regs.b &= 0xF7;
});
decodeMapCB.set(0x99, (z80) => {
    z80.regs.c &= 0xF7;
});
decodeMapCB.set(0x9A, (z80) => {
    z80.regs.d &= 0xF7;
});
decodeMapCB.set(0x9B, (z80) => {
    z80.regs.e &= 0xF7;
});
decodeMapCB.set(0x9C, (z80) => {
    z80.regs.h &= 0xF7;
});
decodeMapCB.set(0x9D, (z80) => {
    z80.regs.l &= 0xF7;
});
decodeMapCB.set(0x9E, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xF7);
});
decodeMapCB.set(0x9F, (z80) => {
    z80.regs.a &= 0xF7;
});
decodeMapCB.set(0xA0, (z80) => {
    z80.regs.b &= 0xEF;
});
decodeMapCB.set(0xA1, (z80) => {
    z80.regs.c &= 0xEF;
});
decodeMapCB.set(0xA2, (z80) => {
    z80.regs.d &= 0xEF;
});
decodeMapCB.set(0xA3, (z80) => {
    z80.regs.e &= 0xEF;
});
decodeMapCB.set(0xA4, (z80) => {
    z80.regs.h &= 0xEF;
});
decodeMapCB.set(0xA5, (z80) => {
    z80.regs.l &= 0xEF;
});
decodeMapCB.set(0xA6, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xEF);
});
decodeMapCB.set(0xA7, (z80) => {
    z80.regs.a &= 0xEF;
});
decodeMapCB.set(0xA8, (z80) => {
    z80.regs.b &= 0xDF;
});
decodeMapCB.set(0xA9, (z80) => {
    z80.regs.c &= 0xDF;
});
decodeMapCB.set(0xAA, (z80) => {
    z80.regs.d &= 0xDF;
});
decodeMapCB.set(0xAB, (z80) => {
    z80.regs.e &= 0xDF;
});
decodeMapCB.set(0xAC, (z80) => {
    z80.regs.h &= 0xDF;
});
decodeMapCB.set(0xAD, (z80) => {
    z80.regs.l &= 0xDF;
});
decodeMapCB.set(0xAE, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xDF);
});
decodeMapCB.set(0xAF, (z80) => {
    z80.regs.a &= 0xDF;
});
decodeMapCB.set(0xB0, (z80) => {
    z80.regs.b &= 0xBF;
});
decodeMapCB.set(0xB1, (z80) => {
    z80.regs.c &= 0xBF;
});
decodeMapCB.set(0xB2, (z80) => {
    z80.regs.d &= 0xBF;
});
decodeMapCB.set(0xB3, (z80) => {
    z80.regs.e &= 0xBF;
});
decodeMapCB.set(0xB4, (z80) => {
    z80.regs.h &= 0xBF;
});
decodeMapCB.set(0xB5, (z80) => {
    z80.regs.l &= 0xBF;
});
decodeMapCB.set(0xB6, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0xBF);
});
decodeMapCB.set(0xB7, (z80) => {
    z80.regs.a &= 0xBF;
});
decodeMapCB.set(0xB8, (z80) => {
    z80.regs.b &= 0x7F;
});
decodeMapCB.set(0xB9, (z80) => {
    z80.regs.c &= 0x7F;
});
decodeMapCB.set(0xBA, (z80) => {
    z80.regs.d &= 0x7F;
});
decodeMapCB.set(0xBB, (z80) => {
    z80.regs.e &= 0x7F;
});
decodeMapCB.set(0xBC, (z80) => {
    z80.regs.h &= 0x7F;
});
decodeMapCB.set(0xBD, (z80) => {
    z80.regs.l &= 0x7F;
});
decodeMapCB.set(0xBE, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value & 0x7F);
});
decodeMapCB.set(0xBF, (z80) => {
    z80.regs.a &= 0x7F;
});
decodeMapCB.set(0xC0, (z80) => {
    z80.regs.b |= 0x01;
});
decodeMapCB.set(0xC1, (z80) => {
    z80.regs.c |= 0x01;
});
decodeMapCB.set(0xC2, (z80) => {
    z80.regs.d |= 0x01;
});
decodeMapCB.set(0xC3, (z80) => {
    z80.regs.e |= 0x01;
});
decodeMapCB.set(0xC4, (z80) => {
    z80.regs.h |= 0x01;
});
decodeMapCB.set(0xC5, (z80) => {
    z80.regs.l |= 0x01;
});
decodeMapCB.set(0xC6, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x01);
});
decodeMapCB.set(0xC7, (z80) => {
    z80.regs.a |= 0x01;
});
decodeMapCB.set(0xC8, (z80) => {
    z80.regs.b |= 0x02;
});
decodeMapCB.set(0xC9, (z80) => {
    z80.regs.c |= 0x02;
});
decodeMapCB.set(0xCA, (z80) => {
    z80.regs.d |= 0x02;
});
decodeMapCB.set(0xCB, (z80) => {
    z80.regs.e |= 0x02;
});
decodeMapCB.set(0xCC, (z80) => {
    z80.regs.h |= 0x02;
});
decodeMapCB.set(0xCD, (z80) => {
    z80.regs.l |= 0x02;
});
decodeMapCB.set(0xCE, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x02);
});
decodeMapCB.set(0xCF, (z80) => {
    z80.regs.a |= 0x02;
});
decodeMapCB.set(0xD0, (z80) => {
    z80.regs.b |= 0x04;
});
decodeMapCB.set(0xD1, (z80) => {
    z80.regs.c |= 0x04;
});
decodeMapCB.set(0xD2, (z80) => {
    z80.regs.d |= 0x04;
});
decodeMapCB.set(0xD3, (z80) => {
    z80.regs.e |= 0x04;
});
decodeMapCB.set(0xD4, (z80) => {
    z80.regs.h |= 0x04;
});
decodeMapCB.set(0xD5, (z80) => {
    z80.regs.l |= 0x04;
});
decodeMapCB.set(0xD6, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x04);
});
decodeMapCB.set(0xD7, (z80) => {
    z80.regs.a |= 0x04;
});
decodeMapCB.set(0xD8, (z80) => {
    z80.regs.b |= 0x08;
});
decodeMapCB.set(0xD9, (z80) => {
    z80.regs.c |= 0x08;
});
decodeMapCB.set(0xDA, (z80) => {
    z80.regs.d |= 0x08;
});
decodeMapCB.set(0xDB, (z80) => {
    z80.regs.e |= 0x08;
});
decodeMapCB.set(0xDC, (z80) => {
    z80.regs.h |= 0x08;
});
decodeMapCB.set(0xDD, (z80) => {
    z80.regs.l |= 0x08;
});
decodeMapCB.set(0xDE, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x08);
});
decodeMapCB.set(0xDF, (z80) => {
    z80.regs.a |= 0x08;
});
decodeMapCB.set(0xE0, (z80) => {
    z80.regs.b |= 0x10;
});
decodeMapCB.set(0xE1, (z80) => {
    z80.regs.c |= 0x10;
});
decodeMapCB.set(0xE2, (z80) => {
    z80.regs.d |= 0x10;
});
decodeMapCB.set(0xE3, (z80) => {
    z80.regs.e |= 0x10;
});
decodeMapCB.set(0xE4, (z80) => {
    z80.regs.h |= 0x10;
});
decodeMapCB.set(0xE5, (z80) => {
    z80.regs.l |= 0x10;
});
decodeMapCB.set(0xE6, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x10);
});
decodeMapCB.set(0xE7, (z80) => {
    z80.regs.a |= 0x10;
});
decodeMapCB.set(0xE8, (z80) => {
    z80.regs.b |= 0x20;
});
decodeMapCB.set(0xE9, (z80) => {
    z80.regs.c |= 0x20;
});
decodeMapCB.set(0xEA, (z80) => {
    z80.regs.d |= 0x20;
});
decodeMapCB.set(0xEB, (z80) => {
    z80.regs.e |= 0x20;
});
decodeMapCB.set(0xEC, (z80) => {
    z80.regs.h |= 0x20;
});
decodeMapCB.set(0xED, (z80) => {
    z80.regs.l |= 0x20;
});
decodeMapCB.set(0xEE, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x20);
});
decodeMapCB.set(0xEF, (z80) => {
    z80.regs.a |= 0x20;
});
decodeMapCB.set(0xF0, (z80) => {
    z80.regs.b |= 0x40;
});
decodeMapCB.set(0xF1, (z80) => {
    z80.regs.c |= 0x40;
});
decodeMapCB.set(0xF2, (z80) => {
    z80.regs.d |= 0x40;
});
decodeMapCB.set(0xF3, (z80) => {
    z80.regs.e |= 0x40;
});
decodeMapCB.set(0xF4, (z80) => {
    z80.regs.h |= 0x40;
});
decodeMapCB.set(0xF5, (z80) => {
    z80.regs.l |= 0x40;
});
decodeMapCB.set(0xF6, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x40);
});
decodeMapCB.set(0xF7, (z80) => {
    z80.regs.a |= 0x40;
});
decodeMapCB.set(0xF8, (z80) => {
    z80.regs.b |= 0x80;
});
decodeMapCB.set(0xF9, (z80) => {
    z80.regs.c |= 0x80;
});
decodeMapCB.set(0xFA, (z80) => {
    z80.regs.d |= 0x80;
});
decodeMapCB.set(0xFB, (z80) => {
    z80.regs.e |= 0x80;
});
decodeMapCB.set(0xFC, (z80) => {
    z80.regs.h |= 0x80;
});
decodeMapCB.set(0xFD, (z80) => {
    z80.regs.l |= 0x80;
});
decodeMapCB.set(0xFE, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.hl, value | 0x80);
});
decodeMapCB.set(0xFF, (z80) => {
    z80.regs.a |= 0x80;
});
const decodeMapDD = new Map();
decodeMapDD.set(0x09, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x19, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x21, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.ix = value;
});
decodeMapDD.set(0x22, (z80) => {
    let value;
    value = z80.regs.ix;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapDD.set(0x23, (z80) => {
    let value;
    value = z80.regs.ix;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.inc16(value);
    z80.regs.ix = value;
});
decodeMapDD.set(0x24, (z80) => {
    let value;
    value = z80.regs.ixh;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.ixh = value;
});
decodeMapDD.set(0x25, (z80) => {
    let value;
    value = z80.regs.ixh;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.ixh = value;
});
decodeMapDD.set(0x26, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.ixh = value;
});
decodeMapDD.set(0x29, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.ix;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x2A, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.ix = value;
});
decodeMapDD.set(0x2B, (z80) => {
    let value;
    value = z80.regs.ix;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.dec16(value);
    z80.regs.ix = value;
});
decodeMapDD.set(0x2C, (z80) => {
    let value;
    value = z80.regs.ixl;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.ixl = value;
});
decodeMapDD.set(0x2D, (z80) => {
    let value;
    value = z80.regs.ixl;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.ixl = value;
});
decodeMapDD.set(0x2E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.ixl = value;
});
decodeMapDD.set(0x34, (z80) => {
    let value;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.add16(z80.regs.ix, z80_base_1.signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x35, (z80) => {
    let value;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.add16(z80.regs.ix, z80_base_1.signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x36, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x39, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.ix + value;
    const lookup = (((z80.regs.ix & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.ix);
    z80.regs.ix = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapDD.set(0x44, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.b = value;
});
decodeMapDD.set(0x45, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.b = value;
});
decodeMapDD.set(0x46, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.b = value;
});
decodeMapDD.set(0x4C, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.c = value;
});
decodeMapDD.set(0x4D, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.c = value;
});
decodeMapDD.set(0x4E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.c = value;
});
decodeMapDD.set(0x54, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.d = value;
});
decodeMapDD.set(0x55, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.d = value;
});
decodeMapDD.set(0x56, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.d = value;
});
decodeMapDD.set(0x5C, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.e = value;
});
decodeMapDD.set(0x5D, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.e = value;
});
decodeMapDD.set(0x5E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.e = value;
});
decodeMapDD.set(0x60, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x61, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x62, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x63, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x64, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x65, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x66, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.h = value;
});
decodeMapDD.set(0x67, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.ixh = value;
});
decodeMapDD.set(0x68, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x69, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6A, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6B, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6C, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6D, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x6E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.l = value;
});
decodeMapDD.set(0x6F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.ixl = value;
});
decodeMapDD.set(0x70, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.b;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x71, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.c;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x72, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.d;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x73, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.e;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x74, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.h;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x75, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.l;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x77, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.a;
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDD.set(0x7C, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.a = value;
});
decodeMapDD.set(0x7D, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.a = value;
});
decodeMapDD.set(0x7E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a = value;
});
decodeMapDD.set(0x84, (z80) => {
    let value;
    value = z80.regs.ixh;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x85, (z80) => {
    let value;
    value = z80.regs.ixl;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x86, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x8C, (z80) => {
    let value;
    value = z80.regs.ixh;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x8D, (z80) => {
    let value;
    value = z80.regs.ixl;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x8E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x94, (z80) => {
    let value;
    value = z80.regs.ixh;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x95, (z80) => {
    let value;
    value = z80.regs.ixl;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x96, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x9C, (z80) => {
    let value;
    value = z80.regs.ixh;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x9D, (z80) => {
    let value;
    value = z80.regs.ixl;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0x9E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapDD.set(0xA4, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapDD.set(0xA5, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapDD.set(0xA6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapDD.set(0xAC, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xAD, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xAE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xB4, (z80) => {
    let value;
    value = z80.regs.ixh;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xB5, (z80) => {
    let value;
    value = z80.regs.ixl;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xB6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapDD.set(0xBC, (z80) => {
    let value;
    value = z80.regs.ixh;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapDD.set(0xBD, (z80) => {
    let value;
    value = z80.regs.ixl;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapDD.set(0xBE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.ix + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapDD.set(0xCB, (z80) => {
    decodeDDCB(z80);
});
decodeMapDD.set(0xE1, (z80) => {
    z80.regs.ix = z80.popWord();
});
decodeMapDD.set(0xE3, (z80) => {
    const rightValue = z80.regs.ix;
    const leftValueL = z80.readByte(z80.regs.sp);
    const leftValueH = z80.readByte(z80_base_1.inc16(z80.regs.sp));
    z80.incTStateCount(1);
    z80.writeByte(z80_base_1.inc16(z80.regs.sp), z80_base_1.hi(rightValue));
    z80.writeByte(z80.regs.sp, z80_base_1.lo(rightValue));
    z80.incTStateCount(2);
    z80.regs.memptr = z80_base_1.word(leftValueH, leftValueL);
    z80.regs.ix = z80_base_1.word(leftValueH, leftValueL);
});
decodeMapDD.set(0xE5, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.ix);
});
decodeMapDD.set(0xE9, (z80) => {
    z80.regs.pc = z80.regs.ix;
});
decodeMapDD.set(0xF9, (z80) => {
    let value;
    value = z80.regs.ix;
    z80.incTStateCount(2);
    z80.regs.sp = value;
});
const decodeMapDDCB = new Map();
decodeMapDDCB.set(0x00, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x01, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x02, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x03, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x04, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x05, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x06, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x07, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x08, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x09, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x0A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x0B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x0C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x0D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x0E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x0F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x10, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x11, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x12, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x13, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x14, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x15, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x16, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x17, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x18, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x19, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x1A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x1B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x1C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x1D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x1E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x1F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x20, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x21, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x22, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x23, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x24, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x25, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x26, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x27, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x28, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x29, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x2A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x2B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x2C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x2D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x2E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x2F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x30, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x31, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x32, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x33, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x34, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x35, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x36, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x37, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x38, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x39, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x3A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x3B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x3C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x3D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x3E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapDDCB.set(0x3F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x47, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x40, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x41, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x42, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x43, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x44, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x45, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x46, decodeMapDDCB.get(0x47));
decodeMapDDCB.set(0x4F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x48, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x49, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x4A, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x4B, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x4C, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x4D, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x4E, decodeMapDDCB.get(0x4F));
decodeMapDDCB.set(0x57, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x50, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x51, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x52, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x53, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x54, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x55, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x56, decodeMapDDCB.get(0x57));
decodeMapDDCB.set(0x5F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x58, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x59, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x5A, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x5B, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x5C, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x5D, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x5E, decodeMapDDCB.get(0x5F));
decodeMapDDCB.set(0x67, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x60, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x61, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x62, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x63, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x64, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x65, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x66, decodeMapDDCB.get(0x67));
decodeMapDDCB.set(0x6F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x68, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x69, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x6A, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x6B, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x6C, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x6D, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x6E, decodeMapDDCB.get(0x6F));
decodeMapDDCB.set(0x77, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x70, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x71, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x72, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x73, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x74, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x75, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x76, decodeMapDDCB.get(0x77));
decodeMapDDCB.set(0x7F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapDDCB.set(0x78, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x79, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x7A, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x7B, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x7C, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x7D, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x7E, decodeMapDDCB.get(0x7F));
decodeMapDDCB.set(0x80, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x81, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x82, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x83, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x84, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x85, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x86, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFE);
});
decodeMapDDCB.set(0x87, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x88, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x89, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x8A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x8B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x8C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x8D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x8E, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFD);
});
decodeMapDDCB.set(0x8F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x90, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x91, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x92, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x93, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x94, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x95, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x96, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFB);
});
decodeMapDDCB.set(0x97, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0x98, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0x99, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0x9A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0x9B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0x9C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0x9D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0x9E, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xF7);
});
decodeMapDDCB.set(0x9F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xA0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xA1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xA2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xA3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xA4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xA5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xA6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xEF);
});
decodeMapDDCB.set(0xA7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xA8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xA9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xAA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xAB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xAC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xAD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xAE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xDF);
});
decodeMapDDCB.set(0xAF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xB0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xB1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xB2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xB3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xB4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xB5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xB6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xBF);
});
decodeMapDDCB.set(0xB7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xB8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xB9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xBA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xBB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xBC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xBD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xBE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0x7F);
});
decodeMapDDCB.set(0xBF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xC0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xC1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xC2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xC3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xC4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xC5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xC6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x01);
});
decodeMapDDCB.set(0xC7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xC8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xC9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xCA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xCB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xCC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xCD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xCE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x02);
});
decodeMapDDCB.set(0xCF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xD0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xD1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xD2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xD3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xD4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xD5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xD6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x04);
});
decodeMapDDCB.set(0xD7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xD8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xD9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xDA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xDB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xDC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xDD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xDE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x08);
});
decodeMapDDCB.set(0xDF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xE0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xE1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xE2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xE3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xE4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xE5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xE6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x10);
});
decodeMapDDCB.set(0xE7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xE8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xE9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xEA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xEB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xEC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xED, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xEE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x20);
});
decodeMapDDCB.set(0xEF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xF0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xF1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xF2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xF3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xF4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xF5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xF6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x40);
});
decodeMapDDCB.set(0xF7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapDDCB.set(0xF8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapDDCB.set(0xF9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapDDCB.set(0xFA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapDDCB.set(0xFB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapDDCB.set(0xFC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapDDCB.set(0xFD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapDDCB.set(0xFE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x80);
});
decodeMapDDCB.set(0xFF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
const decodeMapED = new Map();
decodeMapED.set(0x40, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.b = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.b];
});
decodeMapED.set(0x41, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.b);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x42, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x43, (z80) => {
    let value;
    value = z80.regs.bc;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapED.set(0x7C, (z80) => {
    const value = z80.regs.a;
    z80.regs.a = 0;
    const diff = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    z80.regs.a = diff;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= z80.sz53Table[z80.regs.a];
    z80.regs.f = f;
});
decodeMapED.set(0x44, decodeMapED.get(0x7C));
decodeMapED.set(0x4C, decodeMapED.get(0x7C));
decodeMapED.set(0x54, decodeMapED.get(0x7C));
decodeMapED.set(0x5C, decodeMapED.get(0x7C));
decodeMapED.set(0x64, decodeMapED.get(0x7C));
decodeMapED.set(0x6C, decodeMapED.get(0x7C));
decodeMapED.set(0x74, decodeMapED.get(0x7C));
decodeMapED.set(0x7D, (z80) => {
    z80.regs.iff1 = z80.regs.iff2;
    z80.regs.pc = z80.popWord();
    z80.regs.memptr = z80.regs.pc;
});
decodeMapED.set(0x45, decodeMapED.get(0x7D));
decodeMapED.set(0x55, decodeMapED.get(0x7D));
decodeMapED.set(0x5D, decodeMapED.get(0x7D));
decodeMapED.set(0x65, decodeMapED.get(0x7D));
decodeMapED.set(0x6D, decodeMapED.get(0x7D));
decodeMapED.set(0x75, decodeMapED.get(0x7D));
decodeMapED.set(0x6E, (z80) => {
    z80.regs.im = 0;
});
decodeMapED.set(0x46, decodeMapED.get(0x6E));
decodeMapED.set(0x4E, decodeMapED.get(0x6E));
decodeMapED.set(0x66, decodeMapED.get(0x6E));
decodeMapED.set(0x47, (z80) => {
    let value;
    value = z80.regs.a;
    z80.incTStateCount(1);
    z80.regs.i = value;
});
decodeMapED.set(0x48, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.c = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.c];
});
decodeMapED.set(0x49, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.c);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x4A, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x4B, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.bc = value;
});
decodeMapED.set(0x4D, (z80) => {
    z80.regs.iff1 = z80.regs.iff2;
    z80.regs.pc = z80.popWord();
    z80.regs.memptr = z80.regs.pc;
});
decodeMapED.set(0x4F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.incTStateCount(1);
    z80.regs.r = value;
});
decodeMapED.set(0x50, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.d = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.d];
});
decodeMapED.set(0x51, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.d);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x52, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x53, (z80) => {
    let value;
    value = z80.regs.de;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapED.set(0x76, (z80) => {
    z80.regs.im = 1;
});
decodeMapED.set(0x56, decodeMapED.get(0x76));
decodeMapED.set(0x57, (z80) => {
    let value;
    value = z80.regs.i;
    z80.incTStateCount(1);
    z80.regs.a = value;
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53Table[z80.regs.a] | (z80.regs.iff2 ? z80_base_1.Flag.V : 0);
});
decodeMapED.set(0x58, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.e = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.e];
});
decodeMapED.set(0x59, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.e);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x5A, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x5B, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.de = value;
});
decodeMapED.set(0x7E, (z80) => {
    z80.regs.im = 2;
});
decodeMapED.set(0x5E, decodeMapED.get(0x7E));
decodeMapED.set(0x5F, (z80) => {
    let value;
    value = z80.regs.rCombined;
    z80.incTStateCount(1);
    z80.regs.a = value;
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53Table[z80.regs.a] | (z80.regs.iff2 ? z80_base_1.Flag.V : 0);
});
decodeMapED.set(0x60, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.h = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.h];
});
decodeMapED.set(0x61, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.h);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x62, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.hl;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x63, (z80) => {
    let value;
    value = z80.regs.hl;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapED.set(0x67, (z80) => {
    const tmp = z80.readByte(z80.regs.hl);
    z80.incTStateCount(4);
    z80.writeByte(z80.regs.hl, ((z80.regs.a << 4) | (tmp >> 4)) & 0xFF);
    z80.regs.a = (z80.regs.a & 0xF0) | (tmp & 0x0F);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.a];
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
});
decodeMapED.set(0x68, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.l = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.l];
});
decodeMapED.set(0x69, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.l);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x6A, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.hl;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x6B, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.hl = value;
});
decodeMapED.set(0x6F, (z80) => {
    const tmp = z80.readByte(z80.regs.hl);
    z80.incTStateCount(4);
    z80.writeByte(z80.regs.hl, ((tmp << 4) | (z80.regs.a & 0x0F)) & 0xFF);
    z80.regs.a = (z80.regs.a & 0xF0) | (tmp >> 4);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.a];
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
});
decodeMapED.set(0x70, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.f = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.f];
});
decodeMapED.set(0x71, (z80) => {
    z80.writePort(z80.regs.bc, 0x00);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x72, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.hl - value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result -= 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x73, (z80) => {
    let value;
    value = z80.regs.sp;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapED.set(0x78, (z80) => {
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.a = z80.readPort(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | z80.sz53pTable[z80.regs.a];
});
decodeMapED.set(0x79, (z80) => {
    z80.writePort(z80.regs.bc, z80.regs.a);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
});
decodeMapED.set(0x7A, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.hl + value;
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result += 1;
    }
    const lookup = (((z80.regs.hl & 0x8800) >> 11) |
        ((value & 0x8800) >> 10) |
        ((result & 0x8800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.hl);
    z80.regs.hl = result & 0xFFFF;
    z80.regs.f = ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : z80_base_1.Flag.Z);
});
decodeMapED.set(0x7B, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.sp = value;
});
decodeMapED.set(0xA0, (z80) => {
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    value = z80_base_1.add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.C | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | (value & z80_base_1.Flag.X3) | ((value & 0x02) !== 0 ? z80_base_1.Flag.X5 : 0);
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
    z80.regs.de = z80_base_1.inc16(z80.regs.de);
});
decodeMapED.set(0xA1, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : z80_base_1.Flag.Z) | (diff & z80_base_1.Flag.S);
    if ((z80.regs.f & z80_base_1.Flag.H) !== 0)
        diff = z80_base_1.dec8(diff);
    z80.regs.f |= (diff & z80_base_1.Flag.X3) | (((diff & 0x02) !== 0) ? z80_base_1.Flag.X5 : 0);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.memptr);
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
});
decodeMapED.set(0xA2, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    const other = z80_base_1.inc8(z80_base_1.add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
});
decodeMapED.set(0xA3, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
    const other = z80_base_1.add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
});
decodeMapED.set(0xA8, (z80) => {
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    value = z80_base_1.add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.C | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | (value & z80_base_1.Flag.X3) | ((value & 0x02) !== 0 ? z80_base_1.Flag.X5 : 0);
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
    z80.regs.de = z80_base_1.dec16(z80.regs.de);
});
decodeMapED.set(0xA9, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : z80_base_1.Flag.Z) | (diff & z80_base_1.Flag.S);
    if ((z80.regs.f & z80_base_1.Flag.H) !== 0)
        diff = z80_base_1.dec8(diff);
    z80.regs.f |= (diff & z80_base_1.Flag.X3) | (((diff & 0x02) !== 0) ? z80_base_1.Flag.X5 : 0);
    z80.regs.memptr = z80_base_1.dec16(z80.regs.memptr);
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
});
decodeMapED.set(0xAA, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = z80_base_1.dec16(z80.regs.bc);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    const other = z80_base_1.dec8(z80_base_1.add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
});
decodeMapED.set(0xAB, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    z80.regs.memptr = z80_base_1.dec16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
    const other = z80_base_1.add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
});
decodeMapED.set(0xB0, (z80) => {
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    value = z80_base_1.add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.C | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | (value & z80_base_1.Flag.X3) | ((value & 0x02) !== 0 ? z80_base_1.Flag.X5 : 0);
    if (z80.regs.bc !== 0) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
        z80.regs.memptr = z80_base_1.add16(z80.regs.pc, 1);
    }
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
    z80.regs.de = z80_base_1.inc16(z80.regs.de);
});
decodeMapED.set(0xB1, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : z80_base_1.Flag.Z) | (diff & z80_base_1.Flag.S);
    if ((z80.regs.f & z80_base_1.Flag.H) !== 0)
        diff = z80_base_1.dec8(diff);
    z80.regs.f |= (diff & z80_base_1.Flag.X3) | (((diff & 0x02) !== 0) ? z80_base_1.Flag.X5 : 0);
    if ((z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z)) === z80_base_1.Flag.V) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
        z80.regs.memptr = z80_base_1.add16(z80.regs.pc, 1);
    }
    else {
        z80.regs.memptr = z80_base_1.inc16(z80.regs.memptr);
    }
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
});
decodeMapED.set(0xB2, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    const other = z80_base_1.inc8(z80_base_1.add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
    }
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
});
decodeMapED.set(0xB3, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    z80.regs.memptr = z80_base_1.inc16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = z80_base_1.inc16(z80.regs.hl);
    const other = z80_base_1.add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
    }
});
decodeMapED.set(0xB8, (z80) => {
    let value = z80.readByte(z80.regs.hl);
    z80.writeByte(z80.regs.de, value);
    z80.incTStateCount(2);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    value = z80_base_1.add16(value, z80.regs.a);
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.C | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | (value & z80_base_1.Flag.X3) | ((value & 0x02) !== 0 ? z80_base_1.Flag.X5 : 0);
    if (z80.regs.bc !== 0) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
        z80.regs.memptr = z80_base_1.add16(z80.regs.pc, 1);
    }
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
    z80.regs.de = z80_base_1.dec16(z80.regs.de);
});
decodeMapED.set(0xB9, (z80) => {
    const value = z80.readByte(z80.regs.hl);
    let diff = (z80.regs.a - value) & 0xFF;
    const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
    z80.incTStateCount(5);
    z80.regs.bc = z80_base_1.dec16(z80.regs.bc);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (z80.regs.bc !== 0 ? z80_base_1.Flag.V : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : z80_base_1.Flag.Z) | (diff & z80_base_1.Flag.S);
    if ((z80.regs.f & z80_base_1.Flag.H) !== 0)
        diff = z80_base_1.dec8(diff);
    z80.regs.f |= (diff & z80_base_1.Flag.X3) | (((diff & 0x02) !== 0) ? z80_base_1.Flag.X5 : 0);
    if ((z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z)) === z80_base_1.Flag.V) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
        z80.regs.memptr = z80_base_1.add16(z80.regs.pc, 1);
    }
    else {
        z80.regs.memptr = z80_base_1.dec16(z80.regs.memptr);
    }
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
});
decodeMapED.set(0xBA, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readPort(z80.regs.bc);
    z80.writeByte(z80.regs.hl, value);
    z80.regs.memptr = z80_base_1.dec16(z80.regs.bc);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    const other = z80_base_1.dec8(z80_base_1.add8(value, z80.regs.c));
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
    }
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
});
decodeMapED.set(0xBB, (z80) => {
    z80.incTStateCount(1);
    const value = z80.readByte(z80.regs.hl);
    z80.regs.b = z80_base_1.dec8(z80.regs.b);
    z80.regs.memptr = z80_base_1.dec16(z80.regs.bc);
    z80.writePort(z80.regs.bc, value);
    z80.regs.hl = z80_base_1.dec16(z80.regs.hl);
    const other = z80_base_1.add8(value, z80.regs.l);
    z80.regs.f = (value & 0x80 ? z80_base_1.Flag.N : 0) | (other < value ? z80_base_1.Flag.H | z80_base_1.Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? z80_base_1.Flag.P : 0) | z80.sz53Table[z80.regs.b];
    if (z80.regs.b > 0) {
        z80.incTStateCount(5);
        z80.regs.pc = z80_base_1.add16(z80.regs.pc, -2);
    }
});
const decodeMapFD = new Map();
decodeMapFD.set(0x09, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.bc;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x19, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.de;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x21, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80_base_1.word(z80.readByte(z80.regs.pc), value);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.iy = value;
});
decodeMapFD.set(0x22, (z80) => {
    let value;
    value = z80.regs.iy;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.writeByte(addr, z80_base_1.lo(value));
    addr = z80_base_1.inc16(addr);
    z80.regs.memptr = addr;
    z80.writeByte(addr, z80_base_1.hi(value));
});
decodeMapFD.set(0x23, (z80) => {
    let value;
    value = z80.regs.iy;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.inc16(value);
    z80.regs.iy = value;
});
decodeMapFD.set(0x24, (z80) => {
    let value;
    value = z80.regs.iyh;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.iyh = value;
});
decodeMapFD.set(0x25, (z80) => {
    let value;
    value = z80.regs.iyh;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.iyh = value;
});
decodeMapFD.set(0x26, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.iyh = value;
});
decodeMapFD.set(0x29, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.iy;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x2A, (z80) => {
    let value;
    let addr = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    addr = z80_base_1.word(z80.readByte(z80.regs.pc), addr);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    value = z80.readByte(addr);
    z80.regs.memptr = z80_base_1.inc16(addr);
    value = z80_base_1.word(z80.readByte(z80.regs.memptr), value);
    z80.regs.iy = value;
});
decodeMapFD.set(0x2B, (z80) => {
    let value;
    value = z80.regs.iy;
    const oldValue = value;
    z80.incTStateCount(2);
    value = z80_base_1.dec16(value);
    z80.regs.iy = value;
});
decodeMapFD.set(0x2C, (z80) => {
    let value;
    value = z80.regs.iyl;
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.regs.iyl = value;
});
decodeMapFD.set(0x2D, (z80) => {
    let value;
    value = z80.regs.iyl;
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.regs.iyl = value;
});
decodeMapFD.set(0x2E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.iyl = value;
});
decodeMapFD.set(0x34, (z80) => {
    let value;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.add16(z80.regs.iy, z80_base_1.signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = z80_base_1.inc8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x80 ? z80_base_1.Flag.V : 0) | ((value & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x35, (z80) => {
    let value;
    const offset = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = z80_base_1.add16(z80.regs.iy, z80_base_1.signedByte(offset));
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = z80_base_1.dec8(value);
    z80.regs.f = (z80.regs.f & z80_base_1.Flag.C) | (value === 0x7F ? z80_base_1.Flag.V : 0) | ((oldValue & 0x0F) !== 0 ? 0 : z80_base_1.Flag.H) | z80_base_1.Flag.N | z80.sz53Table[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x36, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x39, (z80) => {
    let value;
    z80.incTStateCount(7);
    value = z80.regs.sp;
    let result = z80.regs.iy + value;
    const lookup = (((z80.regs.iy & 0x0800) >> 11) |
        ((value & 0x0800) >> 10) |
        ((result & 0x0800) >> 9)) & 0xFF;
    z80.regs.memptr = z80_base_1.inc16(z80.regs.iy);
    z80.regs.iy = result & 0xFFFF;
    z80.regs.f = (z80.regs.f & (z80_base_1.Flag.V | z80_base_1.Flag.Z | z80_base_1.Flag.S)) | ((result & 0x10000) !== 0 ? z80_base_1.Flag.C : 0) | ((result >> 8) & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5)) | halfCarryAddTable[lookup];
});
decodeMapFD.set(0x44, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.b = value;
});
decodeMapFD.set(0x45, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.b = value;
});
decodeMapFD.set(0x46, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.b = value;
});
decodeMapFD.set(0x4C, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.c = value;
});
decodeMapFD.set(0x4D, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.c = value;
});
decodeMapFD.set(0x4E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.c = value;
});
decodeMapFD.set(0x54, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.d = value;
});
decodeMapFD.set(0x55, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.d = value;
});
decodeMapFD.set(0x56, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.d = value;
});
decodeMapFD.set(0x5C, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.e = value;
});
decodeMapFD.set(0x5D, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.e = value;
});
decodeMapFD.set(0x5E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.e = value;
});
decodeMapFD.set(0x60, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x61, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x62, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x63, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x64, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x65, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x66, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.h = value;
});
decodeMapFD.set(0x67, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.iyh = value;
});
decodeMapFD.set(0x68, (z80) => {
    let value;
    value = z80.regs.b;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x69, (z80) => {
    let value;
    value = z80.regs.c;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6A, (z80) => {
    let value;
    value = z80.regs.d;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6B, (z80) => {
    let value;
    value = z80.regs.e;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6C, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6D, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x6E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.l = value;
});
decodeMapFD.set(0x6F, (z80) => {
    let value;
    value = z80.regs.a;
    z80.regs.iyl = value;
});
decodeMapFD.set(0x70, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.b;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x71, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.c;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x72, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.d;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x73, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.e;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x74, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.h;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x75, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.l;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x77, (z80) => {
    const dd = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    let value;
    value = z80.regs.a;
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(dd)) & 0xFFFF;
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFD.set(0x7C, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.a = value;
});
decodeMapFD.set(0x7D, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.a = value;
});
decodeMapFD.set(0x7E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a = value;
});
decodeMapFD.set(0x84, (z80) => {
    let value;
    value = z80.regs.iyh;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x85, (z80) => {
    let value;
    value = z80.regs.iyl;
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x86, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.add16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x8C, (z80) => {
    let value;
    value = z80.regs.iyh;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x8D, (z80) => {
    let value;
    value = z80.regs.iyl;
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x8E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.add16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.inc16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x94, (z80) => {
    let value;
    value = z80.regs.iyh;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x95, (z80) => {
    let value;
    value = z80.regs.iyl;
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x96, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.sub16(z80.regs.a, value);
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x9C, (z80) => {
    let value;
    value = z80.regs.iyh;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x9D, (z80) => {
    let value;
    value = z80.regs.iyl;
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0x9E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    let result = z80_base_1.sub16(z80.regs.a, value);
    if ((z80.regs.f & z80_base_1.Flag.C) !== 0) {
        result = z80_base_1.dec16(result);
    }
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((result & 0x88) >> 1)) & 0xFF;
    z80.regs.a = result & 0xFF;
    z80.regs.f = (((result & 0x100) !== 0) ? z80_base_1.Flag.C : 0) | z80_base_1.Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
});
decodeMapFD.set(0xA4, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapFD.set(0xA5, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapFD.set(0xA6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a &= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
    z80.regs.f |= z80_base_1.Flag.H;
});
decodeMapFD.set(0xAC, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xAD, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xAE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a ^= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xB4, (z80) => {
    let value;
    value = z80.regs.iyh;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xB5, (z80) => {
    let value;
    value = z80.regs.iyl;
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xB6, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    z80.regs.a |= value;
    z80.regs.f = z80.sz53pTable[z80.regs.a];
});
decodeMapFD.set(0xBC, (z80) => {
    let value;
    value = z80.regs.iyh;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapFD.set(0xBD, (z80) => {
    let value;
    value = z80.regs.iyl;
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapFD.set(0xBE, (z80) => {
    let value;
    value = z80.readByte(z80.regs.pc);
    z80.incTStateCount(5);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.regs.memptr = (z80.regs.iy + z80_base_1.signedByte(value)) & 0xFFFF;
    value = z80.readByte(z80.regs.memptr);
    const diff = (z80.regs.a - value) & 0xFFFF;
    const lookup = (((z80.regs.a & 0x88) >> 3) |
        ((value & 0x88) >> 2) |
        ((diff & 0x88) >> 1)) & 0xFF;
    let f = z80_base_1.Flag.N;
    if ((diff & 0x100) != 0)
        f |= z80_base_1.Flag.C;
    if (diff == 0)
        f |= z80_base_1.Flag.Z;
    f |= halfCarrySubTable[lookup & 0x07];
    f |= overflowSubTable[lookup >> 4];
    f |= value & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5);
    f |= diff & z80_base_1.Flag.S;
    z80.regs.af = z80_base_1.word(z80.regs.a, f);
});
decodeMapFD.set(0xCB, (z80) => {
    decodeFDCB(z80);
});
decodeMapFD.set(0xE1, (z80) => {
    z80.regs.iy = z80.popWord();
});
decodeMapFD.set(0xE3, (z80) => {
    const rightValue = z80.regs.iy;
    const leftValueL = z80.readByte(z80.regs.sp);
    const leftValueH = z80.readByte(z80_base_1.inc16(z80.regs.sp));
    z80.incTStateCount(1);
    z80.writeByte(z80_base_1.inc16(z80.regs.sp), z80_base_1.hi(rightValue));
    z80.writeByte(z80.regs.sp, z80_base_1.lo(rightValue));
    z80.incTStateCount(2);
    z80.regs.memptr = z80_base_1.word(leftValueH, leftValueL);
    z80.regs.iy = z80_base_1.word(leftValueH, leftValueL);
});
decodeMapFD.set(0xE5, (z80) => {
    z80.incTStateCount(1);
    z80.pushWord(z80.regs.iy);
});
decodeMapFD.set(0xE9, (z80) => {
    z80.regs.pc = z80.regs.iy;
});
decodeMapFD.set(0xF9, (z80) => {
    let value;
    value = z80.regs.iy;
    z80.incTStateCount(2);
    z80.regs.sp = value;
});
const decodeMapFDCB = new Map();
decodeMapFDCB.set(0x00, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x01, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x02, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x03, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x04, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x05, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x06, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | (value >> 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x07, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | (value >> 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x08, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x09, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x0A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x0B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x0C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x0D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x0E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value >> 1) | (value << 7)) & 0xFF;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x0F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value >> 1) | (value << 7)) & 0xFF;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x10, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x11, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x12, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x13, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x14, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x15, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x16, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x17, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 1 : 0)) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x18, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x19, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x1A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x1B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x1C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x1D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x1E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x1F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = (value >> 1) | ((z80.regs.f & z80_base_1.Flag.C) !== 0 ? 0x80 : 0);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x20, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x21, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x22, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x23, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x24, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x25, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x26, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value << 1) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x27, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = (value << 1) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x28, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x29, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x2A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x2B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x2C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x2D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x2E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = (value & 0x80) | (value >> 1);
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x2F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = (value & 0x80) | (value >> 1);
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x30, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x31, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x32, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x33, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x34, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x35, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x36, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = ((value << 1) | 0x01) & 0xFF;
    z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x37, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = ((value << 1) | 0x01) & 0xFF;
        z80.regs.f = ((oldValue & 0x80) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x38, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.b;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.b = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x39, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.c;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.c = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x3A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.d;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.d = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x3B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.e;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.e = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x3C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.h;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.h = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x3D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.l;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.l = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x3E, (z80) => {
    let value;
    value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    const oldValue = value;
    value = value >> 1;
    z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
    z80.writeByte(z80.regs.memptr, value);
});
decodeMapFDCB.set(0x3F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    {
        let value;
        value = z80.regs.a;
        const oldValue = value;
        value = value >> 1;
        z80.regs.f = ((oldValue & 0x01) !== 0 ? z80_base_1.Flag.C : 0) | z80.sz53pTable[value];
        z80.regs.a = value;
    }
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x47, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x01) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x40, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x41, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x42, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x43, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x44, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x45, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x46, decodeMapFDCB.get(0x47));
decodeMapFDCB.set(0x4F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x02) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x48, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x49, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x4A, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x4B, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x4C, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x4D, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x4E, decodeMapFDCB.get(0x4F));
decodeMapFDCB.set(0x57, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x04) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x50, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x51, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x52, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x53, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x54, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x55, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x56, decodeMapFDCB.get(0x57));
decodeMapFDCB.set(0x5F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x08) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x58, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x59, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x5A, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x5B, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x5C, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x5D, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x5E, decodeMapFDCB.get(0x5F));
decodeMapFDCB.set(0x67, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x10) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x60, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x61, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x62, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x63, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x64, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x65, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x66, decodeMapFDCB.get(0x67));
decodeMapFDCB.set(0x6F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x20) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x68, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x69, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x6A, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x6B, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x6C, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x6D, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x6E, decodeMapFDCB.get(0x6F));
decodeMapFDCB.set(0x77, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x40) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x70, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x71, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x72, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x73, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x74, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x75, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x76, decodeMapFDCB.get(0x77));
decodeMapFDCB.set(0x7F, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    const hiddenValue = z80_base_1.hi(z80.regs.memptr);
    z80.incTStateCount(1);
    let f = (z80.regs.f & z80_base_1.Flag.C) | z80_base_1.Flag.H | (hiddenValue & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5));
    if ((value & 0x80) === 0) {
        f |= z80_base_1.Flag.P | z80_base_1.Flag.Z;
    }
    if ((value & 0x80) !== 0) {
        f |= z80_base_1.Flag.S;
    }
    z80.regs.f = f;
});
decodeMapFDCB.set(0x78, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x79, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x7A, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x7B, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x7C, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x7D, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x7E, decodeMapFDCB.get(0x7F));
decodeMapFDCB.set(0x80, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x81, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x82, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x83, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x84, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x85, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x86, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFE);
});
decodeMapFDCB.set(0x87, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFE;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x88, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x89, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x8A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x8B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x8C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x8D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x8E, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFD);
});
decodeMapFDCB.set(0x8F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFD;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x90, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x91, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x92, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x93, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x94, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x95, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x96, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xFB);
});
decodeMapFDCB.set(0x97, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xFB;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0x98, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0x99, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0x9A, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0x9B, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0x9C, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0x9D, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0x9E, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xF7);
});
decodeMapFDCB.set(0x9F, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xF7;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xA0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xA1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xA2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xA3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xA4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xA5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xA6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xEF);
});
decodeMapFDCB.set(0xA7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xEF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xA8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xA9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xAA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xAB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xAC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xAD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xAE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xDF);
});
decodeMapFDCB.set(0xAF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xDF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xB0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xB1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xB2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xB3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xB4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xB5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xB6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0xBF);
});
decodeMapFDCB.set(0xB7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0xBF;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xB8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xB9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xBA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xBB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xBC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xBD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xBE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value & 0x7F);
});
decodeMapFDCB.set(0xBF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) & 0x7F;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xC0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xC1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xC2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xC3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xC4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xC5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xC6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x01);
});
decodeMapFDCB.set(0xC7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x01;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xC8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xC9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xCA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xCB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xCC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xCD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xCE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x02);
});
decodeMapFDCB.set(0xCF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x02;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xD0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xD1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xD2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xD3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xD4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xD5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xD6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x04);
});
decodeMapFDCB.set(0xD7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x04;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xD8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xD9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xDA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xDB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xDC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xDD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xDE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x08);
});
decodeMapFDCB.set(0xDF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x08;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xE0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xE1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xE2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xE3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xE4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xE5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xE6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x10);
});
decodeMapFDCB.set(0xE7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x10;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xE8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xE9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xEA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xEB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xEC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xED, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xEE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x20);
});
decodeMapFDCB.set(0xEF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x20;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xF0, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xF1, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xF2, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xF3, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xF4, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xF5, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xF6, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x40);
});
decodeMapFDCB.set(0xF7, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x40;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
decodeMapFDCB.set(0xF8, (z80) => {
    z80.regs.b = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.b);
});
decodeMapFDCB.set(0xF9, (z80) => {
    z80.regs.c = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.c);
});
decodeMapFDCB.set(0xFA, (z80) => {
    z80.regs.d = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.d);
});
decodeMapFDCB.set(0xFB, (z80) => {
    z80.regs.e = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.e);
});
decodeMapFDCB.set(0xFC, (z80) => {
    z80.regs.h = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.h);
});
decodeMapFDCB.set(0xFD, (z80) => {
    z80.regs.l = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.l);
});
decodeMapFDCB.set(0xFE, (z80) => {
    const value = z80.readByte(z80.regs.memptr);
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, value | 0x80);
});
decodeMapFDCB.set(0xFF, (z80) => {
    z80.regs.a = z80.readByte(z80.regs.memptr) | 0x80;
    z80.incTStateCount(1);
    z80.writeByte(z80.regs.memptr, z80.regs.a);
});
/**
 * Fetch an instruction for decode.
 */
function fetchInstruction(z80) {
    z80.incTStateCount(4);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.regs.pc = (z80.regs.pc + 1) & 0xFFFF;
    z80.regs.r = (z80.regs.r + 1) & 0xFF;
    return inst;
}
/**
 * Decode the "CB" prefix (bit instructions).
 */
function decodeCB(z80) {
    const inst = fetchInstruction(z80);
    const func = decodeMapCB.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in CB: " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
/**
 * Decode the "DD" prefix (IX instructions).
 */
function decodeDD(z80) {
    const inst = fetchInstruction(z80);
    const func = decodeMapDD.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in DD: " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
/**
 * Decode the "DDCB" prefix (IX bit instructions).
 */
function decodeDDCB(z80) {
    z80.incTStateCount(3);
    const offset = z80.readByteInternal(z80.regs.pc);
    z80.regs.memptr = z80_base_1.add16(z80.regs.ix, z80_base_1.signedByte(offset));
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.incTStateCount(3);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    const func = decodeMapDDCB.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in DDCB: " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
/**
 * Decode the "ED" prefix (extended instructions).
 */
function decodeED(z80) {
    const inst = fetchInstruction(z80);
    const func = decodeMapED.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in ED: " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
/**
 * Decode the "FD" prefix (IY instructions).
 */
function decodeFD(z80) {
    const inst = fetchInstruction(z80);
    const func = decodeMapFD.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in FD: " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
/**
 * Decode the "FDCB" prefix (IY bit instructions).
 */
function decodeFDCB(z80) {
    z80.incTStateCount(3);
    const offset = z80.readByteInternal(z80.regs.pc);
    z80.regs.memptr = z80_base_1.add16(z80.regs.iy, z80_base_1.signedByte(offset));
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    z80.incTStateCount(3);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.incTStateCount(2);
    z80.regs.pc = z80_base_1.inc16(z80.regs.pc);
    const func = decodeMapFDCB.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode in FDCB: " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
/**
 * Decode the base (un-prefixed) instructions.
 */
function decode(z80) {
    const inst = fetchInstruction(z80);
    const func = decodeMapBASE.get(inst);
    if (func === undefined) {
        console.log("Unhandled opcode " + z80_base_1.toHex(inst, 2));
    }
    else {
        func(z80);
    }
}
exports.decode = decode;


/***/ }),

/***/ "./node_modules/z80-emulator/dist/Z80.js":
/*!***********************************************!*\
  !*** ./node_modules/z80-emulator/dist/Z80.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const z80_base_1 = __webpack_require__(/*! z80-base */ "./node_modules/z80-base/dist/index.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./node_modules/z80-emulator/dist/Decode.js");
/**
 * Emulated Z80 processor.
 */
class Z80 {
    constructor(hal) {
        /**
         * Full set of registers.
         */
        this.regs = new z80_base_1.RegisterSet();
        /**
         * Tables for computing flags. Public so that the decoding function
         * can access them.
         */
        this.sz53Table = []; /* The S, Z, 5 and 3 bits of the index */
        this.parityTable = []; /* The parity of the lookup value */
        this.sz53pTable = []; /* OR the above two tables together */
        this.hal = hal;
        this.initTables();
    }
    /**
     * Reset the Z80 to a known state.
     */
    reset() {
        this.regs = new z80_base_1.RegisterSet();
    }
    /**
     * Execute one instruction.
     */
    step() {
        Decode_1.decode(this);
    }
    /**
     * Increment the clock count.
     */
    incTStateCount(count) {
        this.hal.tStateCount += count;
    }
    /**
     * Interrupt the CPU with a maskable interrupt
     */
    maskableInterrupt() {
        if (this.regs.iff1 !== 0) {
            this.interrupt(true);
        }
    }
    /**
     * Interrupt the CPU with a non-maskable interrupt
     */
    nonMaskableInterrupt() {
        this.interrupt(false);
    }
    /**
     * Read a byte from memory, taking as many clock cycles as necessary.
     */
    readByte(address) {
        this.incTStateCount(3);
        return this.readByteInternal(address);
    }
    /**
     * Reads a word at the specified address. Reads the low byte first.
     */
    readWord(address) {
        const lowByte = this.readByte(address);
        const highByte = this.readByte(address + 1);
        return z80_base_1.word(highByte, lowByte);
    }
    /**
     * Read a byte from memory (not affecting clock).
     */
    readByteInternal(address) {
        return this.hal.readMemory(address);
    }
    /**
     * Write a byte to memory, taking as many clock cycles as necessary.
     */
    writeByte(address, value) {
        this.incTStateCount(3);
        this.writeByteInternal(address, value);
    }
    /**
     * Write a byte to memory (not affecting clock).
     */
    writeByteInternal(address, value) {
        this.hal.writeMemory(address, value);
    }
    /**
     * Write a byte to a port, taking as many clock cycles as necessary.
     */
    writePort(address, value) {
        this.incTStateCount(1);
        this.hal.writePort(address, value);
        this.incTStateCount(3);
    }
    /**
     * Read a byte from a port, taking as many clock cycles as necessary.
     */
    readPort(address) {
        this.incTStateCount(1);
        const value = this.hal.readPort(address);
        this.incTStateCount(3);
        return value;
    }
    /**
     * Push a word on the stack.
     */
    pushWord(value) {
        this.pushByte(z80_base_1.hi(value));
        this.pushByte(z80_base_1.lo(value));
    }
    /**
     * Push a byte on the stack.
     */
    pushByte(value) {
        this.regs.sp = (this.regs.sp - 1) & 0xFFFF;
        this.writeByte(this.regs.sp, value);
    }
    /**
     * Pop a word from the stack.
     */
    popWord() {
        const lowByte = this.popByte();
        const highByte = this.popByte();
        return z80_base_1.word(highByte, lowByte);
    }
    /**
     * Pop a byte from the stack.
     */
    popByte() {
        const value = this.readByte(this.regs.sp);
        this.regs.sp = z80_base_1.inc16(this.regs.sp);
        return value;
    }
    /**
     * Process either kind of interrupt. If maskable, assumes that
     * the mask has already been checked.
     */
    interrupt(maskable) {
        if (this.regs.halted) {
            // Skip past HALT instruction.
            this.regs.pc++;
            this.regs.halted = 0;
        }
        this.incTStateCount(7);
        this.regs.r += 1;
        this.regs.iff1 = 0;
        this.regs.iff2 = 0;
        this.pushWord(this.regs.pc);
        if (maskable) {
            switch (this.regs.im) {
                case 0:
                case 1:
                    this.regs.pc = 0x0038;
                    break;
                case 2: {
                    // The LSB here is taken from the data bus, so it's
                    // unpredictable. We use 0xFF but any value would do.
                    const address = z80_base_1.word(this.regs.i, 0xFF);
                    this.regs.pc = this.readWord(address);
                    break;
                }
                default:
                    throw new Error("Unknown im mode " + this.regs.im);
            }
        }
        else {
            this.regs.pc = 0x0066;
        }
    }
    initTables() {
        for (let i = 0; i < 0x100; i++) {
            this.sz53Table.push(i & (z80_base_1.Flag.X3 | z80_base_1.Flag.X5 | z80_base_1.Flag.S));
            let bits = i;
            let parity = 0;
            for (let bit = 0; bit < 8; bit++) {
                parity ^= bits & 1;
                bits >>= 1;
            }
            this.parityTable.push(parity ? 0 : z80_base_1.Flag.P);
            this.sz53pTable.push(this.sz53Table[i] | this.parityTable[i]);
        }
        this.sz53Table[0] |= z80_base_1.Flag.Z;
        this.sz53pTable[0] |= z80_base_1.Flag.Z;
    }
}
exports.Z80 = Z80;


/***/ }),

/***/ "./node_modules/z80-emulator/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/z80-emulator/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(/*! ./Z80 */ "./node_modules/z80-emulator/dist/Z80.js"));


/***/ })

}]);